\chapter{Introduction}
\minitoc

\section{What is \it{competitive programming}?}

\it{Competitive programming} is basically a type of programming that you need to solve the algorithmic problems in a competitive manner, e.g. fast and efficient, in order to compete with others. Usually, two things needed to consider for programming competitively are (1) \bf{time constraint} and (2) \bf{memory constraint}, and most of the time the deciding factor is (1) time constraint mainly because, for instance, if you have to make an algorithm that takes an input of order $O(n^2)$ but you need to compute an output in $O(n \log n)$, this would be impossible as the bottleneck of your program is $O(n^2)$ from taking in an input.

For the sake of people who still have no idea what \it{competitive programming} is, I would like to give an example of problems, which are so-called competitive programming tasks:

\begin{flushleft}
	\bf{Problem: } Let $X$ be the array of size $N$ of integers with elements $x_i$. Suppose you want 	to find the minimum number of swaps with consecutive elements in the list do you need to do in order to make the array sorted, either in ascending order or descending order. \\
	\bf{Input constraint:} $1 \le N \le 10^5$, $1 \le x_i \le 10^{18}$. \\
	\bf{Time limit:} 1 second
\end{flushleft}

In this problem, you have to find how to swap elements in order to make the array sorted and why the method you found is optimal. If you have some backgrounds on this kind of problems, first you would realize that you have to solve this problem twice, one for the ascending order case and another one for the descending order case. Then, you would realize that you just need to find that if you can swap any consecutive elements in order to make the list sorted, then you will swap these two elements and count how many times you do swap. However, the method we just said is in order of $O(N^2)$ and would be impossible to run in the time limit. One approach you will learn in the future is to use either \it{Merge sort} or \it{Fenwick Tree/Segment Tree} to count the number of times you do swap, which is in the order of $O(n \log n)$ and faster enough to finish in the time contraint.

\section{What is the prerequisite for \it{competitive programming}?}
These are very formulaic. I will list everything I know that is important to \it{competitive programming}:
\begin{enumerate}
	\item Mathematics
	\subitem Combinatorics (Counting / 
	\subitem Number Theory (Inverse modular, Euclid)
	\subitem Geometry (Convex Hull, Trivial Geometry)
	\subitem Graph Theory (BFS/DFS/Tree/Shortest Path/Euclidean/Hamiltonian/Network Flow/Matching)
	\item Algorithms
	\subitem Numerical Algorithms
	\subitem Solving paradigm Algorithms (DP/Greedy/Brute force/D\&Q)
	\subitem Graph Algorithms
	\subitem Computational Geometry Algorithms
	\item Data Structures
	\subitem Basic (Queue/Stack/Linked list)
	\subitem Union-Disjoint Set
	\subitem Fenwick Tree
	\subitem Segment Tree
	\item STL
\end{enumerate}

\section{Where can I practice it?}
Again, there are so many websites you can practice at:
\begin{enumerate}
	\item Topcoder
	\item Codeforces
	\item SPOJ
	\item Google Code Jam
	\item Facebook Hacker Cup
	\item UVA Online Judge
\end{enumerate}
That's more than enough that you can do.

\section{How I design this book?}
First, I will delve deeper into mathematics you needed to understand and will go to algorithms \& data structures.

\section{Who am I?}
